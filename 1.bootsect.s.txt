每天一个Linux源代码解析，今天讲解第一个文件bootsect.s文件。

1.这是一个汇编代码文件，bootsect.s，顾名思义，这个代码的功能就是boot-sect，也就是加载-扇区的意思。所以这个源代码的功能已经很明确了，就是加载位于硬盘扇区里面的数据，加载到哪里去呢？肯定是在内存里面去，对吧。

2.那么我着重讲解以下几个点：

2.1.为什么是位于硬盘的扇区数据？而不是内存、CPU内部中的？
	- 显然，在计算机中，有CPU内部RAM(寄存器、高速缓存)、内存、硬盘等等数据存储介质，但是为什么偏偏是硬盘呢？显然，CPU和内存中的介质是易失性的，所以不能持久化，数据掉电就没了，这肯定不是我们想要的结果。这是其一；
	其二，越慢越便宜，容量也越大，像一般的操作系统的容量都是比较大的，所以我们需要采用大容量存储介质，那么硬盘是当之无愧的了。
	

2.2加载硬盘中的那些位置扇区的数据？有没有定数，以什么为定数？还是胡乱加载？
	- 我直接给出答案，计算机的世界是很规矩的，当然有定数。这里分为三大块数据，三个批次加载。

第一个批次，是加载硬盘中的第一个扇区的512字节的内容；
第二批次，加载的2~5个，共4个扇区的2MB字节数据；
第三个批次，加载的从第6个扇区开始的240个扇区的数据。

为什么分为这三个批次呢？实际上以功能为标准分批次，这三块二进制数据块，功能各异，但是构筑了整个操作系统。

2.3最开始的数据怎么放进对应指定的扇区的？最开始也没有操作系统啊？

	- 最开始是使用机器码写的操作系统，编译时，就可以指定将编译后的块编译到什么地方，所以，这才有了这些数据块明确的存储的地方，也便于我们的CPU加载。

2.4加载到内存哪里去？有没有定数？还是胡乱加载存放？

有，第一个数据块，会放置在以0x7c00为起始的物理内存处；
第二个批次，会放置在0x90200处开始的物理内存处；
第三个批次，会放置在0x10000处开始的物理内存处；

2.5加载后还有内存架构初始化的动作，具体有哪些动作？
具体分为两个：复制+内存架构初始化

 - 复制：一个是将第一个批次的数据块加载到了0x7c00处后，会立即将这些512B数据块移动到以0x90000为起始地址的物理内存处。
 - 内存架构初始化：为CPU的段寄存器赋初值，给堆栈指针赋初值。本质是初步架构好内存的代码段、数据段、堆栈段，为CPU合理访问内存做好铺垫。


2.6给出从头到尾的执行流程？
最开始，我们按下开机键，这个时候，并不会一开始就显示登录界面，往往有一些启动时间，按下开机键到显示欢迎登录期间干的事，就是操作系统的启动过程。

我们有一个既定事实，就是计算机的本质是CPU计算核心一直在进行计算的，所以我们做的所有工作，都是指示CPU从哪里取数据，进行什么样的计算罢了。而从哪里取数据，很简单，就是从IP寄存器里面取。怎么计算？这就是我们要做的大功夫。本质上编程很大一部分就是针对此的。所以，我们只需要设置IP寄存器的值，就可以指明CPU，从哪里执行。

开机后，CPU的IP寄存器被强制设置为0xFFFF0,也就是从这里取值，而这里的内存被映射为主板上的固件BIOS的程序，所以一开机，执行的是BIOS芯片的写死的程序。
这个程序做两件大事，一件就是检查各个设备有没有问题，鼠标、键盘、屏幕坏没坏等等，另一个事，就是完成我们的第一批次数据块的加载。



学习Linux内核使我快乐，看了这份视频，希望你也能快乐，我们下期见。

为什么不从0x00000开始？因为这是BIOS的数据区，有中断代码等等。